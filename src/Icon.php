<?php

namespace App\UI;

use App\Common\href;
use App\Common\SQL\Factory;
use App\Common\str;

/**
 * Class icon
 * @package app\common
 */
class Icon {
	/**
	 * Default icons for common form field names, input type, and notifications.
	 * Can be overridden or removed if icon is specifically set or set to FALSE.
	 */
	const DEFAULTS = [
		"phone" => "phone",
		"email" => "envelope",
		"password" => "key",
		"money" => "pound-sign",
		"date" => "calendar",
		"error" => [
			"type" => "solid",
			"name" => "ban"
		],
		"danger" => [
			"type" => "solid",
			"name" => "ban"
		],
		"success" => [
			"type" => "solid",
			"name" => "check"
		],
		"info" => [
			"type" => "thin",
			"name" => "info-circle"
		],
		"warning" => [
			"type" => "solid",
			"name" => "exclamation-triangle"
		],
	];

	/**
	 * Returns the correct name for the Font Awesome icon weights.
	 *
	 * @param $type string regular, solid or light, everything else defaults to regular.
	 *
	 * @return string far, fas, or fal
	 */
	static function getType($type = NULL){
		switch($type){
		case 'regular': return 'far'; break;
		case 'far': return 'far'; break;

		case 'duotone': return 'fad'; break;
		case 'fad': return 'fad'; break;

		case 'solid': return 'fas'; break;
		case 'bold': return 'fas'; break;
		case 'thick': return 'fas'; break;
		case 'full': return 'fas'; break;
		case 'fas': return 'fas'; break;

		case 'light': return 'fal'; break;
		case 'thin': return 'fal'; break;
		case 'fal': return 'fal'; break;

		case 'brand': return 'fab'; break;
		case 'fab': return 'fab'; break;

		case 'flag': return 'flag'; break;

		default: return "far"; break;
		}
	}

	/**
	 * Translates the $icon setting to an
	 * icon array. Useful to run before generating
	 * an icon HTML string, because you don't know
	 * whether a simple icon name, or a complex set
	 * of icon instructions have been sent thru.
	 *
	 * @param $icon array|string
	 *
	 * @return array
	 */
	static function getArray($icon){
		# If complex icon instructions have been given
		if(is_array($icon)) {
			$icon['type'] = self::getType($icon['type']);
			return $icon;
		}

		# If a default name has been given
		if(key_exists($icon, self::DEFAULTS)){
			$icon_array = self::DEFAULTS[$icon];
			$icon_array['type'] = $icon_array['type'] ?: self::getType();
			return $icon_array;
		}

		# If simply an icon name has been given
		return [
			"type" => self::getType(),
			"name" => $icon,
			"colour" => false
		];
	}

	/**
	 * Gets the actual name of the icon class.
	 *
	 * <code>
	 * $icon_class = Icon::getClass($icon);
	 * </code>
	 *
	 * @param $icon_array
	 *
	 * @return bool|string
	 */
	static function getClass($icon_array){
		extract(Icon::getArray($icon_array));

		if(!$name){
			return false;
		}

		$name = strtolower($name);
		//Names are case sensitive, they're all lowercase

		if($size){
			$size = " fa-{$size}";
		}

		if($class){
			$class = " {$class}";
		}

		if($type == "flag"){
			//if this is an flag-icon-css type icon
			$squared = $squared ? " flag-icon-squared" : "";
			return "flag-icon flag-icon-{$name}{$class}{$squared}";
		}

		return "{$type} fa-{$name} fa-fw{$size}{$class}";
	}

	/**
	 * Icons can be stacked.
	 * Experimental.
	 *
	 * @param $stacked
	 *
	 * @return string
	 */
	private static function generate_stacked($stacked){
		$highest_stack = 1;
		foreach($stacked as $stack){
			$icon_array = [];
			if(is_string($stack)){
				$icon_array['name'] = $stack;
			} else {
				$icon_array = $stack;
			}
			$icon_array['stack'] = $icon_array['stack'] ?: $highest_stack++;
			$icon_array['class'] .= "fa-stack-{$icon_array['stack']}x";
			$icon_stack[] = self::generate($icon_array);
			$highest_stack = $icon_array['stack'] > $highest_stack ? $icon_array['stack'] : $highest_stack;
		}
		$class = str::getAttrTag("class", "fa-stack");
		$style = str::getAttrTag("style", "margin:-3px 0px -8px -6px;");
		return "<span {$class} {$style}>".implode("\r\n", $icon_stack)."</span>";
	}

	/**
	 * Returns the actual i-tag HTMl that is the icon..
	 * Requires either an array of icon information,
	 * or a string with the array name.
	 *
	 * <code>
	 * $icon_html = Icon::generate([
	 * 	"name" => "copy",
	 * 	"type" => "thin",
	 * 	"transform" => "left-8"
	 * ]);
	 *
	 * $icon_html = Icon::generate("copy");
	 * </code>
	 *
	 * @param $a array|string The array generated by Icon::getArray(), or an icon name.
	 *
	 * @return string
	 */
	static function generate($a = NULL){
		if(!$a){
			return false;
		}

		if(!is_array($a)) {
			//if the only thing passed is the name of the icon
			$icon_array['name'] = $a;
		} else if(str::isNumericArray($a)){
			//if several icons are to be stacked
			return self::generate_stacked($a);
		} else {
			$icon_array = $a;
		}

		extract(Icon::getArray($icon_array));

		if(!$default[] = Icon::getClass($icon_array)){
			return false;
		}
		if($colour){
			$default[] = " text-{$colour}";
		}

		if($approve){
			//if an approval dialogue is to prepend the action
			$id = $id ?: str::id("icon");
			// We'll need an ID

			$approve_attr = str::getApproveAttr($a['approve']);
			$default[] = "approve-decision";
		}

		$class_array = str::getAttrArray($class, $default, $only_class);

		$title = str::getAttrTag("title", $alt ?: $title);

		if($href = href::generate($icon_array)){
			$a_pre = "<a {$href}>";
			$a_post = "</a>";
		}

		$id = str::getAttrTag("id", $id);
		$style = str::getAttrTag("style", $style);
		$transform = str::getAttrTag("data-fa-transform", $transform);
		$class = str::getAttrTag("class", $class_array);

		return <<<EOF
{$a_pre}<i{$id}{$class}{$style}{$transform}{$title}{$approve_attr} aria-hidden="true"></i>{$a_post}
EOF;
	}

	/**
	 * Get an icon name from the database table icon.
	 *
	 * @param $rel_table
	 *
	 * @return string
	 */
	static function get($rel_table){
		$sql = Factory::getInstance();
		$icon = $sql->select([
			"table" => "icon",
			"where" => [
				"rel_table" => $rel_table
			],
			"limit" => 1
		]);
		return $icon['icon'] ?: $rel_table;
	}
}